---
layout: post
comment: false
title: Golang Basic
date: 2020-03-17
category: "Golang"
tags: [Golang]
author: Jaehyun Lee
---
### Golang Basic
---

##### 상수
- const 키워드 사용
- const 키워드를 생략할 수 없기 떄문에 ':=' 이용한 타입 추론 불가능.
- 괄호로 여러개 상수를 묶어 초기화 가능(상수 선언간 개행 필요.)
{% highlight go %}
const (
	val1 = 1
	val2 = 2
)
{% endhighlight %}
---

##### 증감연산자
- 전위 연산자 사용 불가능
- 정수, 실수, 복소수에 대해 증감 연산 가능

---

##### 논리연산자
- bool형(true,false)에 대해서만 논리 연산 가능, 다른 언어 처럼 1과 0에 대해서 논리연산 불가능.

---
##### 포인터
- C처럼 포인터 사용 가능. & (메모리 주소 참조), *(메모리에 접근, 값 참조)
- 포인터 산술 연산은 제공하지 않음... 그럼 뭐에다 쓰려고...

#### **자료형**
---

##### Sizeof
- Unsafe 패키지의 Sizeof 함수로 타입 size 확인 가능

##### Boolean Type
- 1 Byte
- Go에서는 true와 false만 사용하여 값 할당

##### Integer Type
- 32bit 시스템에서 32비트, 64bit 시스템에서 64비트
- int8, int16, int32, int64, uint8 ... uintptr(8Byte)
- uintptr은 포인트 주소 할당할 때 주로 사용.

##### Floating Point Type
- float32, float64

##### 문자열 타입
- 16 Byte
- string으로 선언한 문자열 타입은 immutable 타입으로, 값 수정 불가능

##### etc.
- byte (1Byte), 바이트 값을 8bit uint와 구별해 사용
- rune (4Btye), 문자 값을 정수 값과 구별하기 위해 사용

##### 자료형 Casting
- 명시적 형변환 해줘야함
{% highlight go %}
var str string = "Hello"
changeStr := []byte(str) // string -> byte 배열
str2 := string(changeStr)
{% endhighlight %}

#### **for**
---

- Golang은 while 지원하지 않음. 오로지 for

##### 기본 형태
{% highlight go %}
for i:= 0 ; i < n; i++ {
	...
}
{% endhighlight %}

##### 무한 loop
{% highlight go %}
for {
    ...
}
{% endhighlight %}

##### for range
- foreach와 비슷, for index, 요소값 := range 컬렉션 이름

#### **조건, 제어문**
---

- Only True, False, Not 1,0
- Go에서는 조건문 한 줄일때도 중괄호 생략 불가능
- 괄호 시작과 else문 같은 줄에.

##### Break, Continue, Goto
- break, continue 키워드로 사용 가능
- break문 뒤에 레이블과 같이 사용되면 지정된 레이블로 이동 가능
{% highlight go %}
func main() {
	i := 0
LABEL1:
	for {
		if i == 0 {
			break LABEL1
		}
	}

// break문이 바로 빠져나왔던 for문 다음 문장 실행
	fmt.Println("End")
	goto LABEL1
}
{% endhighlight %}

#### **Collection**
---
- Go에서 두 개 이상의 변수를 모아 놓은 것을 컬렉션이라..


##### Array
- Go에서 배열은 정적. 고정된 크기. 
그래서 배열 크기를 동적으로 사이징하거나 부분 배열만 가져오는 기능은 없다.
- 배열의 크기는 자료형을 구성하는 하나의 요소로, 2[int]와 3[int]는 자료형 자체가 다른 것이다. 
- var arrName [사이즈]자료형
- 자바나 C++처럼 배열 크기를 데이터 타입 앞에 쓰는 방식 안됨.
{% highlight go %}
func main(){
	var arr1 [5]int
	fmt.Println(arr1)
	// [0 0 0 0 0] 출력
	arr2 := [5]int{1, 2, 3, 4, 5} // type 추론 가능
	fmt.Println(arr1)
	// [1 2 3 4 5]
	var arr3 = [...]int{9, 8, 7, 6} // [...] 이용해 배열 크기 자동 설정
	fmt.Println(len(arr3))
	// 4
}
{% endhighlight %}

##### Slice
- Go에서 배열은 필요에 따라 동적으 크기를 증가시키는 등의 기능을 가지고있지 않다. Slice는 배열과 다르게 고정된 크기를 미리 지정하지 않아도 필요에 따라 크기를 동적으로 변경할수 있고 부분 추출이 가능하다.

![Image](/assets/images/slice-structure.png){:style=" width: 80%; margin: 0 auto; display: block;"}

- Slice는 초기화하지 않아도 배열 위치를 가리키는 ptr, 배열 길이 len, 용량인 cap 변수를 위한 메모리를 가지고 있다. 

- Slice는 참조 타입, 참조하고 있는 slice의 값을 변경하게 되면?
{% highlight go %}
func main(){
	var a []int
	a = []int{1,2,3,4,5}
	a[0] = 10
	a[1] = 20
	a[2] = 30
	a[3] = 40
	a[4] = 50
	b := a[2:4]
	b[1]= 45
	fmt.Println(a)
	// [10 20 30 45 50] 출력
}
{% endhighlight %}

##### make()
- make(type, length, capacity) 형태로 선언

{% highlight go %}
func main(){
	a := make([]int, 0, 2)
	for i:=0 ; i < 9 ; i++ {
		a = append(a, i)
		fmt.Println("len :", len(a), "cap :", cap(a))
	}
}

output 
len : 3 cap : 4
len : 4 cap : 4
len : 5 cap : 8
len : 6 cap : 8
len : 7 cap : 8
len : 8 cap : 8
len : 9 cap : 16
{% endhighlight %}

- slice에 메모리 공간이 추가될 때마다 다른 메모리에 기존+새로운 공간 크기만큼의 메모리를 할당하고 원본을 복사하는식으로 동작하는데, 매번 공간 할당과 원본 데이터를 복사하면 비효율적이기 때문에 capacity를 두배씩 늘려주는게 아닌가 싶은데, 기초다지고 다시 알아보기로. 

- append()로 slice에 slice 추가 가능
{% highlight go %}
sliceA := []int{1,2}
sliceB := []int{4,5}
slice A = append(sliceA, slicdeB**...**)
{% endhighlight %}
