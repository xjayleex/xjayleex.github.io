---
layout: post
comment: false
title: Golang Basic
date: 2020-03-17
category: "Golang"
tags: [Golang]
author: Jaehyun Lee
---
### Golang Basic
---

##### 상수
- const 키워드 사용
- const 키워드를 생략할 수 없기 떄문에 ':=' 이용한 타입 추론 불가능.
- 괄호로 여러개 상수를 묶어 초기화 가능(상수 선언간 개행 필요.)
{% highlight go %}
const (
	val1 = 1
	val2 = 2
)
{% endhighlight %}
---

##### 증감연산자
- 전위 연산자 사용 불가능
- 정수, 실수, 복소수에 대해 증감 연산 가능

---

##### 논리연산자
- bool형(true,false)에 대해서만 논리 연산 가능, 다른 언어 처럼 1과 0에 대해서 논리연산 불가능.

---
##### 포인터
- C처럼 포인터 사용 가능. & (메모리 주소 참조), *(메모리에 접근, 값 참조)
- 포인터 산술 연산은 제공하지 않음... 그럼 뭐에다 쓰려고...

#### **자료형**
---

##### Sizeof
- Unsafe 패키지의 Sizeof 함수로 타입 size 확인 가능

##### Boolean Type
- 1 Byte
- Go에서는 true와 false만 사용하여 값 할당

##### Integer Type
- 32bit 시스템에서 32비트, 64bit 시스템에서 64비트
- int8, int16, int32, int64, uint8 ... uintptr(8Byte)
- uintptr은 포인트 주소 할당할 때 주로 사용.

##### Floating Point Type
- float32, float64

##### 문자열 타입
- 16 Byte
- string으로 선언한 문자열 타입은 immutable 타입으로, 값 수정 불가능

##### etc.
- byte (1Byte), 바이트 값을 8bit uint와 구별해 사용
- rune (4Btye), 문자 값을 정수 값과 구별하기 위해 사용

##### 자료형 Casting
- 명시적 형변환 해줘야함
{% highlight go %}
var str string = "Hello"
changeStr := []byte(str) // string -> byte 배열
str2 := string(changeStr)
{% endhighlight %}

#### **for**
---

- Golang은 while 지원하지 않음. 오로지 for

##### 기본 형태
{% highlight go %}
for i:= 0 ; i < n; i++ {
	...
}
{% endhighlight %}

##### 무한 loop
{% highlight go %}
for {
    ...
}
{% endhighlight %}

##### for range
- foreach와 비슷, for index, 요소값 := range 컬렉션 이름

#### **조건, 제어문**
---

- Only True, False, Not 1,0
- Go에서는 조건문 한 줄일때도 중괄호 생략 불가능
- 괄호 시작과 else문 같은 줄에.

##### Break, Continue, Goto
- break, continue 키워드로 사용 가능
- break문 뒤에 레이블과 같이 사용되면 지정된 레이블로 이동 가능
{% highlight go %}
func main() {
	i := 0
LABEL1:
	for {
		if i == 0 {
			break LABEL1
		}
	}

// break문이 바로 빠져나왔던 for문 다음 문장 실행
	fmt.Println("End")
	goto LABEL1
}
{% endhighlight %}

#### **Collection**
---
- Go에서 두 개 이상의 변수를 모아 놓은 것을 컬렉션이라..


##### Array
- Go에서 배열은 정적. 고정된 크기. 
그래서 배열 크기를 동적으로 사이징하거나 부분 배열만 가져오는 기능은 없다.
- 배열의 크기는 자료형을 구성하는 하나의 요소로, 2[int]와 3[int]는 자료형 자체가 다른 것이다. 
- var arrName [사이즈]자료형
- 자바나 C++처럼 배열 크기를 데이터 타입 앞에 쓰는 방식 안됨.
{% highlight go %}
func main(){
	var arr1 [5]int
	fmt.Println(arr1)
	// [0 0 0 0 0] 출력
	arr2 := [5]int{1, 2, 3, 4, 5} // type 추론 가능
	fmt.Println(arr1)
	// [1 2 3 4 5]
	var arr3 = [...]int{9, 8, 7, 6} // [...] 이용해 배열 크기 자동 설정
	fmt.Println(len(arr3))
	// 4
}
{% endhighlight %}

##### Slice
