---
layout: post
comment: false
title: JSON and Go
date: 2020-08-12
category: "Golang"
tags: [Golang, JSON in go]
update: 2020-08-06
author: Jaehyun Lee
---
> ### Contents
[**Introduction**](#introduction)  
[**Declaration and Initialization**](#declaration-and-initialization**)  
[**Working with maps**](#working-with-maps)  
[**Exploiting zero values**](#exploiting-zero-values**)  
[**Key types**](#key-types)  
[**Concurrency**](#concurrency)  
[**Iteration order**](#iteration-order)

#### Intoduction
---
`JSON(JavaScript Object Notation)`은 Key-Value 형태의 간단한 데이터 교환 방식으로, 문법적으로는 자바 스크립트의 객체와 리스트와 유사하다. JSON은 웹 백엔드와 클라이언트 사이의 통신에 가장 일반적으로 사용되지만 다른 많은 곳에서도 사용된다. Go에서는 `json` 패키지를 통해 쉽게 JSON 데이터를 읽고 쓸 수 있다.

#### Encoding
---
문자로 'a'라는 값은 정수 바이트 값으로 97이다. 메모리에서의 바이트는 해석하는 틀에 따라 다른데, 이러한 변환을 `Encoding`, `Marshaling`이라 한다.

JSON 데이터를 인코딩하기 위해서 `Marshal` 함수를 사용한다.
```go
func Marshal(v interface{}) ([]byte, error)
```
다음과 같은 Message 라는 자료구조가 있고, `m`과 같은 Message의 인스턴스가 있다고 하자.
```go
type Message struct{
	Name	string
	Body	string
	Time	int64
}

m := Message{"Alice", "Hello", 1294706395881547000}
```
위에서 설명한바와 같이 `json.Marshal`을 통해 JSON 인코딩으로 마샬링 할 수 있다.
```go
b, err := json.Marshal(m)
```
아무 문제가 없다면, `err`는 nil일테고, `b`에는 Byte Slice 형식의 JSON 데이터가 들어간다.
인코딩 시, JSON으로 표시할 수 있는 데이터 구조만 인코딩 할 수 있다.
- JSON 객체는 키로써 string만 지원한다. map 타입을 마샬링하려면 map[string]Type 형식이어야 한다. 
- Channel, Complex, 함수 타입은 인코딩 할 수 없다.
- Cyclic 데이터 구조는 지원되지 않는다. 
- 포인터는 그 포인터가 가리키는 값으로 인코딩된다.(포인터가 nil이라면 `null`으로.)

`json` 패키지는 구조체 내부의 Exported 필드(대문자로 시작하는 public한 필드)에만 액세스한다. 

#### Decoding
---
역으로 JSON 데이터를 디코딩하기 위해 `Unmarshal` 함수를 사용한다.
```go
func Unmarshal(data []byte, v interface{}) error
```
디코딩된 데이터가 저장될 타입 변수를 선언하고 JSON 바이트 슬라이스와 변수에 대한 포인터를 인자로 `json.Unmarshal`을 호출한다.
```go
var m Message
err := jsom.Unmarshal(b, &m)
```
만약 `b`가 `m`에 알맞는 데이터를 가지고 있다면, `err`는 nil이 되고 `b`로부터 디코딩된 데이터가 `m` 변수에 다음과 같이 할당했을때 처럼 올라온다. 
```go
m = Message{
	Name: "Alice",
	Body: "Hello",
	Time: 1294706395881547000,
}
```
이 때 `Unmarshal` 함수는 어떻게 디코딩된 데이터를 저장할 필드를 매핑할까? JSON 키 `Foo`에 대해서 `Unmarshal`은 다음과 같은 선호 순서대로 구조체 내의 대상 필드를 찾는다.
- "Foo"로 태그된 Exported 필드.
- "Foo"로 네이밍된 Exported 필드.
- "FOO" 또는 "FoO" 처럼 "Foo"의 대소문자를 구분하지 않았을 때의 일치 항목.

Go 타입과 JSON 데이터가 정확히 매치되지 않았을 때는 어떤 일이 발생할까?
```go
b := []byte(`{"Name":"Bob","Food":"Pickle"}`)
var m Message
err := json.Unmarshal(b, &m)
```
`Unmarshal`은 구조체 내에서 찾을 수 있는 대상 타입에 대해서는 언마샬링한다. 위의 경우에서는 `m`의 Name 필드만 채워지고 Food 필드는 무시된다. 이 특성은 큰 JSON blob에서 특정한 필드들만 선택하려는 경우 유용하게 쓰인다. 또한 대상 구조체의 Unexported 필드는 `Unmarshal`의 영향을 받지 않는다.

하지만 JSON 데이터의 구조를 미리 알지 못할때에는 어떻게 될까?

#### Generic JSON with interface{}
---

